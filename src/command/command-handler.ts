import { ResultAsync, errAsync, fromPromise, okAsync } from 'neverthrow'
import type { AggregateId, AggregateType } from '../types/aggregate-id'
import {
  type AppError,
  createNotFoundError,
  createStoreOperationError
} from '../types/app-error'
import type { Command, CommandResultAsync } from '../types/command'
import type { EventDecider, Reducer, State } from '../types/command-aggregate'
import type { DomainEvent, DomainEventPayload } from '../types/domain-event'
import type { EventStore } from '../types/event-store'
import type { Snapshot } from '../types/snapshot'

import { decideAndReduce } from './functional-aggregate'
import { reconstructState } from './functional-aggregate'

/** Frequency (in number of events) to save snapshots. */
const SNAPSHOT_INTERVAL = 100

/** Type definition for a function that processes a command. */
export type ProcessCommandFn = (command: Command) => CommandResultAsync

/**
 * Creates a command processing function (handler) for a specific aggregate type.
 * This function uses event sourcing and snapshotting.
 *
 * @template S - The type of the aggregate state.
 * @template C - The specific type of command this handler processes.
 * @template P - The specific type(s) of domain event payload generated by the decider.
 * @param decider - Function to decide events (type P) based on state and command.
 * @param reducer - Function to apply events to the state.
 * @param createInitialState - Function to create the initial state for a new aggregate.
 * @param eventStore - The event store implementation.
 * @returns A function that takes a command and returns a CommandResultAsync.
 */
export function createCommandHandler<
  S extends State,
  C extends Command,
  P extends DomainEventPayload
>(
  decider: EventDecider<S, C, P>,
  reducer: Reducer<S, P>,
  createInitialState: (type: AggregateType, id: AggregateId) => S,
  eventStore: EventStore<S, P>
): ProcessCommandFn {
  /**
   * Loads the current state and version of an aggregate,
   * utilizing snapshots and event history.
   */
  const loadStateAndVersion = (
    aggregateType: AggregateType,
    aggregateIdFromCommand: AggregateId
  ): ResultAsync<
    { state: S; version: number; aggregateId: AggregateId },
    AppError
  > => {
    const loadSnapshotResult = ResultAsync.fromPromise(
      eventStore.loadSnapshot(aggregateType),
      e =>
        createStoreOperationError('Failed to load snapshot', 'loadSnapshot', {
          cause: e,
          details: { aggregateType }
        })
    )

    return loadSnapshotResult.andThen(snapshot => {
      const version = snapshot?.version ?? 0
      const currentAggregateId =
        snapshot?.state.aggregateId ?? aggregateIdFromCommand

      const loadHistoryResult = ResultAsync.fromPromise(
        eventStore.loadHistory(aggregateType, version),
        e =>
          createStoreOperationError('Failed to load history', 'loadHistory', {
            cause: e,
            details: { aggregateType, fromVersion: version }
          })
      )

      return loadHistoryResult.map(history => {
        const { state, version: finalVersion } = reconstructState(
          snapshot,
          history,
          createInitialState,
          reducer,
          aggregateType,
          currentAggregateId
        )
        return { state, version: finalVersion, aggregateId: currentAggregateId }
      })
    })
  }

  /**
   * Saves newly generated events and potentially a snapshot.
   */
  const saveEventsAndSnapshot = (
    newState: S,
    newVersion: number,
    events: DomainEvent<P>[]
  ): ResultAsync<void, AppError> => {
    const saveEventsResult = ResultAsync.fromPromise(
      eventStore.save(events),
      e =>
        createStoreOperationError('Failed to save events', 'save', {
          cause: e,
          details: { events }
        })
    )

    return saveEventsResult.andThen(() => {
      if (newVersion % SNAPSHOT_INTERVAL === 0) {
        return ResultAsync.fromPromise(
          eventStore.saveSnapshot({
            aggregateId: newState.aggregateId,
            aggregateType: newState.aggregateType,
            state: newState,
            version: newVersion,
            timestamp: new Date()
          }),
          e =>
            createStoreOperationError(
              'Failed to save snapshot',
              'saveSnapshot',
              {
                cause: e,
                details: { state: newState, version: newVersion }
              }
            )
        )
      }
      return okAsync(undefined)
    })
  }

  return (command: Command): CommandResultAsync => {
    return loadStateAndVersion(
      command.aggregateType,
      command.aggregateId
    ).andThen(({ state, version, aggregateId }) => {
      if (aggregateId !== command.aggregateId) {
        return errAsync(
          createNotFoundError(
            `Aggregate ${command.aggregateType} with id ${command.aggregateId} not found`
          )
        )
      }

      return decideAndReduce(state, command, decider, reducer, version).andThen(
        ({ newState, newVersion, events }) =>
          saveEventsAndSnapshot(newState, newVersion, events).map(() => events)
      )
    })
  }
}
