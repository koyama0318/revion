import { ResultAsync, errAsync, okAsync } from 'neverthrow'
import type { AggregateId, AggregateType } from '../types/aggregate-id'
import {
  type AppError,
  createNotFoundError,
  createStoreOperationError
} from '../types/app-error'
import type { Command, CommandResultAsync } from '../types/command'
import type { EventDecider, Reducer, State } from '../types/command-aggregate'
import type { DomainEvent, DomainEventPayload } from '../types/domain-event'
import type { EventStore } from '../types/event-store'
import type { Snapshot } from '../types/snapshot'

import { decideAndReduce } from './functional-aggregate'
import { reconstructState } from './functional-aggregate'

/** Frequency (in number of events) to save snapshots. */
const SNAPSHOT_INTERVAL = 100

/** Type definition for a function that processes a command. */
export type ProcessCommandFn = (command: Command) => CommandResultAsync

/**
 * Creates a command processing function (handler) for a specific aggregate type.
 * This function uses event sourcing and snapshotting.
 *
 * @template S - The type of the aggregate state.
 * @template C - The specific type of command this handler processes.
 * @template P - The specific type(s) of domain event payload generated by the decider.
 * @param decider - Function to decide events (type P) based on state and command.
 * @param reducer - Function to apply events to the state.
 * @param createInitialState - Function to create the initial state for a new aggregate.
 * @param eventStore - The event store implementation.
 * @returns A function that takes a command and returns a CommandResultAsync.
 */
export function createCommandHandler<
  S extends State,
  C extends Command,
  P extends DomainEventPayload
>(
  decider: EventDecider<S, C, P>,
  reducer: Reducer<S, P>,
  createInitialState: (type: AggregateType, id: AggregateId) => S,
  eventStore: EventStore<S, P>
): ProcessCommandFn {
  /**
   * Loads the current state and version of an aggregate,
   * utilizing snapshots and event history.
   */
  const loadStateAndVersion = (
    aggregateType: AggregateType,
    aggregateIdFromCommand: AggregateId
  ): ResultAsync<
    { state: S; version: number; aggregateId: AggregateId },
    AppError
  > => {
    // First, try to load snapshot
    const loadSnapshotResult = ResultAsync.fromPromise(
      eventStore.loadSnapshot(aggregateType, aggregateIdFromCommand),
      e =>
        createStoreOperationError('Failed to load snapshot', 'loadSnapshot', {
          cause: e,
          details: { aggregateType }
        })
    )

    // Then load history after the snapshot
    return loadSnapshotResult.andThen(snapshotResult => {
      const snapshot = snapshotResult.isOk() ? snapshotResult.value : undefined
      const version = snapshot?.version ?? 0
      const currentAggregateId =
        snapshot?.state.aggregateId ?? aggregateIdFromCommand

      const loadHistoryResult = ResultAsync.fromPromise(
        eventStore.loadHistory(aggregateType, aggregateIdFromCommand, version),
        e =>
          createStoreOperationError('Failed to load history', 'loadHistory', {
            cause: e,
            details: { aggregateType, fromVersion: version }
          })
      )

      return loadHistoryResult.map(historyResult => {
        const history = historyResult.isOk() ? historyResult.value : []
        const { state, version: newVersion } = reconstructState(
          snapshot,
          history,
          createInitialState,
          reducer,
          aggregateType,
          currentAggregateId
        )

        return {
          state,
          version: newVersion,
          aggregateId: currentAggregateId
        }
      })
    })
  }

  /**
   * Saves newly generated events and potentially a snapshot.
   */
  const saveEventsAndSnapshot = (
    newState: S,
    newVersion: number,
    events: DomainEvent<P>[]
  ): ResultAsync<void, AppError> => {
    // Save events first
    const saveEventsResult = ResultAsync.fromPromise(
      eventStore.save(events[0].aggregateType, events[0].aggregateId, events),
      e =>
        createStoreOperationError('Failed to save events', 'saveEvents', {
          cause: e,
          details: { events }
        })
    )

    // Then conditionally save snapshot
    return saveEventsResult.andThen(() => {
      if (newVersion % SNAPSHOT_INTERVAL === 0) {
        // Save snapshot if at the interval
        return ResultAsync.fromPromise(
          eventStore.saveSnapshot(
            events[0].aggregateType,
            events[0].aggregateId,
            {
              aggregateId: newState.aggregateId,
              aggregateType: newState.aggregateType,
              state: newState,
              version: newVersion,
              timestamp: new Date()
            }
          ),
          e =>
            createStoreOperationError(
              'Failed to save snapshot',
              'saveSnapshot',
              {
                cause: e,
                details: { state: newState, version: newVersion }
              }
            )
        ).map(() => undefined)
      }
      return okAsync(undefined)
    })
  }

  // The actual command handler function
  return (command: Command): CommandResultAsync => {
    // Load the state
    return loadStateAndVersion(
      command.aggregateType,
      command.aggregateId
    ).andThen(({ state, version, aggregateId }) => {
      // Verify the aggregate exists and matches
      if (aggregateId !== command.aggregateId) {
        return errAsync(
          createNotFoundError(
            `Aggregate ${command.aggregateType} with id ${command.aggregateId} not found`
          )
        )
      }

      // Process the command to generate events
      const decideResult = decideAndReduce(
        state,
        command as C,
        decider,
        reducer,
        version
      )

      if (decideResult.isErr()) {
        return errAsync(decideResult.error)
      }

      const { newState, newVersion, events } = decideResult.value

      // Save events and snapshot
      return saveEventsAndSnapshot(newState, newVersion, events).map(() => ({
        newState: newState as State,
        events: events as DomainEvent<DomainEventPayload>[]
      }))
    })
  }
}
