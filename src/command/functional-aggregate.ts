import { type Result, err, ok } from 'neverthrow'
import { v4 as uuidv4 } from 'uuid'
import type { AggregateId, AggregateType } from '../types/aggregate-id'
import type { AppError } from '../types/app-error'
import type { Command } from '../types/command'
import type { EventDecider, Reducer, State } from '../types/command-aggregate'
import type { DomainEvent, DomainEventPayload } from '../types/domain-event'
import type { Snapshot } from '../types/snapshot'

/**
 * Applies a command to the current state to decide and reduce new events.
 * This function aims to be pure, taking state and functions as input.
 *
 * @template S - The type of the aggregate state.
 * @template C - The type of the command.
 * @template P - The specific type of payload generated by the decider.
 * @param currentState - The current state of the aggregate.
 * @param command - The command to process.
 * @param decider - The function to decide event payloads (type P) from the state and command.
 * @param reducer - The function to apply an event to the state and return the new state.
 * @param currentVersion - The current version of the aggregate.
 * @returns A Result containing the new state, new version, and generated events on success, or an AppError on failure.
 */
export function decideAndReduce<
  S extends State,
  C extends Command,
  P extends DomainEventPayload
>(
  state: S,
  command: C,
  decider: EventDecider<S, C, P>,
  reducer: Reducer<S, P>,
  version: number
): Result<
  { newState: S; newVersion: number; events: DomainEvent<P>[] },
  AppError
> {
  const eventsResult = decider(state, command)
  if (eventsResult.isErr()) {
    return err(eventsResult.error)
  }

  const events = eventsResult.value.map((payload, index) => ({
    eventId: `event-${version + index + 1}`,
    aggregateId: state.aggregateId,
    aggregateType: state.aggregateType,
    eventType: command.operation,
    version: version + index + 1,
    payload,
    timestamp: new Date()
  }))

  const newState = events.reduce(
    (currentState, event) => reducer(currentState, event),
    state
  )

  return ok({
    newState,
    newVersion: version + events.length,
    events
  })
}

/**
 * Reconstructs the latest state and version of an aggregate from a snapshot and event history.
 *
 * @template S - The type of the aggregate state.
 * @template P - The specific type of domain event payload.
 * @param snapshot - The latest available snapshot, or undefined.
 * @param history - An array of domain events that occurred after the snapshot (if any).
 * @param createInitialState - A function to create the initial state if no snapshot exists.
 * @param reducer - The function to apply an event to the state.
 * @param aggregateType - The type of the aggregate.
 * @param aggregateId - The ID of the aggregate.
 * @returns An object containing the reconstructed state and version.
 */
export function reconstructState<S extends State, P extends DomainEventPayload>(
  snapshot: Snapshot<S> | undefined,
  history: DomainEvent<P>[],
  createInitialState: (type: AggregateType, id: AggregateId) => S,
  reducer: Reducer<S, P>,
  aggregateType: AggregateType,
  aggregateId: AggregateId
): { state: S; version: number } {
  let currentState =
    snapshot?.state ?? createInitialState(aggregateType, aggregateId)
  let currentVersion = snapshot?.version ?? 0

  for (const event of history) {
    // Apply only relevant events that are newer than the snapshot version
    if (
      event.aggregateType === aggregateType &&
      event.aggregateId === aggregateId &&
      event.version > currentVersion
    ) {
      currentState = reducer(currentState, event)
      currentVersion = event.version
    }
  }

  return { state: currentState, version: currentVersion }
}
