import { type Result, err, ok } from 'neverthrow'
import { v4 as uuidv4 } from 'uuid'
import type { AppError } from '../types/app-error'
import type { Command } from '../types/command'
import type { EventDecider, Reducer, State } from '../types/command-aggregate'
import type { DomainEvent, DomainEventPayload } from '../types/event'
import type { AggregateId, AggregateType } from '../types/id'
import type { Snapshot } from '../types/snapshot'

/**
 * Applies a command to the current state to decide and reduce new events.
 * This function aims to be pure, taking state and functions as input.
 *
 * @template S - The type of the aggregate state.
 * @template C - The type of the command.
 * @template P - The specific type of payload generated by the decider.
 * @param currentState - The current state of the aggregate.
 * @param currentVersion - The current version of the aggregate.
 * @param command - The command to process.
 * @param decider - The function to decide event payloads (type P) from the state and command.
 * @param reducer - The function to apply an event to the state and return the new state.
 * @returns A Result containing the new state and generated events (as DomainEvent<P>) on success, or an AppError on failure.
 */
export function decideAndReduce<
  S extends State,
  C extends Command,
  P extends DomainEventPayload
>(
  currentState: S,
  currentVersion: number,
  command: C,
  decider: EventDecider<S, C, P>,
  reducer: Reducer<S>
): Result<{ newState: S; newEvents: DomainEvent<P>[] }, AppError> {
  const eventPayloadsResult = decider(currentState, command)

  if (eventPayloadsResult.isErr()) {
    return err(eventPayloadsResult.error)
  }

  const eventPayloads = eventPayloadsResult.value
  const newEvents: DomainEvent<P>[] = []
  let nextState = currentState
  let versionCounter = currentVersion

  for (const payload of eventPayloads) {
    versionCounter++
    const event: DomainEvent<P> = {
      eventId: uuidv4(),
      aggregateType: command.aggregateType,
      aggregateId: command.aggregateId,
      eventType: command.operation,
      version: versionCounter,
      payload,
      timestamp: new Date()
    }
    nextState = reducer(nextState, event as DomainEvent<DomainEventPayload>)
    newEvents.push(event)
  }

  return ok({ newState: nextState, newEvents })
}

/**
 * Reconstructs the latest state and version of an aggregate from a snapshot and event history.
 *
 * @template S - The type of the aggregate state.
 * @param snapshot - The latest available snapshot, or undefined.
 * @param history - An array of domain events that occurred after the snapshot (if any).
 * @param createInitialState - A function to create the initial state if no snapshot exists.
 * @param reducer - The function to apply an event to the state.
 * @param aggregateType - The type of the aggregate.
 * @param aggregateId - The ID of the aggregate.
 * @returns An object containing the reconstructed state and version.
 */
export function reconstructState<S extends State>(
  snapshot: Snapshot<S> | undefined,
  history: DomainEvent<DomainEventPayload>[],
  createInitialState: (type: AggregateType, id: AggregateId) => S,
  reducer: Reducer<S>,
  aggregateType: AggregateType,
  aggregateId: AggregateId
): { state: S; version: number } {
  let currentState =
    snapshot?.state ?? createInitialState(aggregateType, aggregateId)
  let currentVersion = snapshot?.version ?? 0

  for (const event of history) {
    // Apply only relevant events that are newer than the snapshot version
    if (
      event.aggregateType === aggregateType &&
      event.aggregateId === aggregateId &&
      event.version > currentVersion
    ) {
      currentState = reducer(currentState, event)
      currentVersion = event.version
    }
  }

  return { state: currentState, version: currentVersion }
}
