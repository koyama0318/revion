import { ResultAsync, errAsync, fromPromise, okAsync } from 'neverthrow'
import {
  type AppError,
  createNotFoundError,
  createStoreOperationError
} from '../types/app-error'
import type { Command, CommandResultAsync } from '../types/command'
import type { EventDecider, Reducer, State } from '../types/command-aggregate'
import type { DomainEvent, DomainEventPayload } from '../types/event'
import type { EventStore } from '../types/event-store'
import type { AggregateId, AggregateType } from '../types/id'
import type { Snapshot } from '../types/snapshot'

import { decideAndReduce } from './functional-aggregate'
import { reconstructState } from './functional-aggregate'

/** Frequency (in number of events) to save snapshots. */
const SNAPSHOT_INTERVAL = 100

/** Type definition for a function that processes a command. */
export type ProcessCommandFn = (command: Command) => CommandResultAsync

/**
 * Creates a command processing function (handler) for a specific aggregate type.
 * This function uses event sourcing and snapshotting.
 *
 * @template S - The type of the aggregate state.
 * @template C - The specific type of command this handler processes.
 * @template P - The specific type(s) of domain event payload generated by the decider.
 * @param decider - Function to decide events (type P) based on state and command.
 * @param reducer - Function to apply events to the state.
 * @param createInitialState - Function to create the initial state for a new aggregate.
 * @param eventStore - The event store implementation.
 * @returns A function that takes a command and returns a CommandResultAsync.
 */
export function createCommandHandler<
  S extends State,
  C extends Command,
  P extends DomainEventPayload
>(
  decider: EventDecider<S, C, P>,
  reducer: Reducer<S>,
  createInitialState: (type: AggregateType, id: AggregateId) => S,
  eventStore: EventStore
): ProcessCommandFn {
  /**
   * Loads the current state and version of an aggregate,
   * utilizing snapshots and event history.
   */
  const loadStateAndVersion = (
    aggregateType: AggregateType,
    aggregateIdFromCommand: AggregateId
  ): ResultAsync<
    { state: S; version: number; aggregateId: AggregateId },
    AppError
  > => {
    const loadSnapshotResult = ResultAsync.fromPromise(
      eventStore.loadSnapshot<S>(aggregateType),
      e =>
        createStoreOperationError('Failed to load snapshot', 'loadSnapshot', {
          cause: e,
          details: { aggregateType }
        })
    )

    return loadSnapshotResult.andThen(snapshot => {
      const version = snapshot?.version ?? 0
      const currentAggregateId =
        snapshot?.state.aggregateId ?? aggregateIdFromCommand

      const loadHistoryResult = ResultAsync.fromPromise(
        eventStore.loadHistory(aggregateType, version),
        e =>
          createStoreOperationError('Failed to load history', 'loadHistory', {
            cause: e,
            details: { aggregateType, fromVersion: version }
          })
      )

      return loadHistoryResult.map(history => {
        const { state, version: finalVersion } = reconstructState(
          snapshot,
          history,
          createInitialState,
          reducer,
          aggregateType,
          currentAggregateId
        )
        return { state, version: finalVersion, aggregateId: currentAggregateId }
      })
    })
  }

  /**
   * Saves newly generated events and potentially a snapshot.
   */
  const saveEventsAndSnapshot = (
    newState: S,
    newVersion: number,
    events: DomainEvent<DomainEventPayload>[]
  ): ResultAsync<void, AppError> => {
    const saveEventsResult = ResultAsync.fromPromise(
      eventStore.save(events),
      error =>
        createStoreOperationError('Failed to save events', 'saveEvents', {
          cause: error,
          details: { eventCount: events.length }
        })
    )

    return saveEventsResult.andThen(() => {
      // Save snapshot periodically.
      // TODO: Improve snapshot condition (e.g., based on last snapshot version).
      if (newVersion > 0 && newVersion % SNAPSHOT_INTERVAL === 0) {
        const snapshot: Snapshot<S> = {
          aggregateId: newState.aggregateId,
          aggregateType: newState.aggregateType,
          state: newState,
          version: newVersion,
          timestamp: new Date()
        }
        return ResultAsync.fromPromise(eventStore.saveSnapshot(snapshot), e =>
          createStoreOperationError('Failed to save snapshot', 'saveSnapshot', {
            cause: e,
            details: {
              aggregateId: snapshot.aggregateId,
              version: snapshot.version
            }
          })
        )
      }
      return okAsync(undefined)
    })
  }

  // The actual command processing function returned by the factory.
  return (command: Command): CommandResultAsync => {
    const { aggregateType, aggregateId } = command

    return (
      loadStateAndVersion(aggregateType, aggregateId)
        .andThen(({ state, version }) => {
          // Decide and reduce events based on the loaded state and command.
          const dispatchResult = decideAndReduce<S, C, P>(
            state,
            version,
            command as C,
            decider,
            reducer
          )

          if (dispatchResult.isErr()) {
            return errAsync(dispatchResult.error)
          }

          const { newState, newEvents } = dispatchResult.value

          // If no events were generated, do nothing.
          if (newEvents.length === 0) {
            return okAsync(undefined)
          }

          // Save the new events and potentially a snapshot.
          const finalVersion = newEvents[newEvents.length - 1].version
          return saveEventsAndSnapshot(
            newState,
            finalVersion,
            newEvents as DomainEvent<DomainEventPayload>[]
          )
        })
        // Map the final successful result to undefined (command execution doesn't return data).
        .map(() => undefined)
    )
  }
}
